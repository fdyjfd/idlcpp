//DO NOT EDIT THIS FILE, it is generated by idlcpp
//http://www.idlcpp.org

#pragma once

#include "String.mh"
#include "AutoRun.h"
#include "NameSpace.h"
#include "Result.h"
#include "Argument.h"
#include "InstanceField.h"
#include "StaticField.h"
#include "InstanceProperty.h"
#include "InstanceArrayProperty.h"
#include "StaticProperty.h"
#include "StaticArrayProperty.h"
#include "InstanceMethod.h"
#include "StaticMethod.h"
#include "Enumerator.h"
#include "PrimitiveType.h"
#include "VoidType.h"
#include "RefCountImpl.h"
#include <new>


namespace idlcpp
{

	__pafcore__String_Type::__pafcore__String_Type() : ::pafcore::ClassType("String", ::pafcore::value_object)
	{
		m_size = sizeof(::pafcore::String);
		static ::pafcore::Result s_staticResults[] = 
		{
			::pafcore::Result(RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), false, ::pafcore::Result::by_new),
			::pafcore::Result(RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), false, ::pafcore::Result::by_new),
			::pafcore::Result(RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), false, ::pafcore::Result::by_new),
			::pafcore::Result(RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), false, ::pafcore::Result::by_new_array),
		};
		static ::pafcore::Argument s_staticArguments[] = 
		{
			::pafcore::Argument("arg", RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), ::pafcore::Argument::by_ref, true),
			::pafcore::Argument("str", RuntimeTypeOf<char>::RuntimeType::GetSingleton(), ::pafcore::Argument::by_ptr, true),
			::pafcore::Argument("count", RuntimeTypeOf<unsigned int>::RuntimeType::GetSingleton(), ::pafcore::Argument::by_value, false),
		};
		static ::pafcore::Overload s_staticOverloads[] = 
		{
			::pafcore::Overload(&s_staticResults[0], 0, 0, true, false),
			::pafcore::Overload(&s_staticResults[1], &s_staticArguments[0], 1, true, false),
			::pafcore::Overload(&s_staticResults[2], &s_staticArguments[1], 1, true, false),
			::pafcore::Overload(&s_staticResults[3], &s_staticArguments[2], 1, true, false),
		};
		static ::pafcore::StaticMethod s_staticMethods[] = 
		{
			::pafcore::StaticMethod("New", 0, String_New, &s_staticOverloads[0], 3),
			::pafcore::StaticMethod("NewArray", 0, String_NewArray, &s_staticOverloads[3], 1),
		};
		m_staticMethods = s_staticMethods;
		m_staticMethodCount = paf_array_size_of(s_staticMethods);
		static ::pafcore::Result s_instanceResults[] = 
		{
			::pafcore::Result(RuntimeTypeOf<void>::RuntimeType::GetSingleton(), false, ::pafcore::Result::by_value),
			::pafcore::Result(RuntimeTypeOf<void>::RuntimeType::GetSingleton(), false, ::pafcore::Result::by_value),
			::pafcore::Result(RuntimeTypeOf<void>::RuntimeType::GetSingleton(), false, ::pafcore::Result::by_value),
			::pafcore::Result(RuntimeTypeOf<void>::RuntimeType::GetSingleton(), false, ::pafcore::Result::by_value),
			::pafcore::Result(RuntimeTypeOf<char>::RuntimeType::GetSingleton(), true, ::pafcore::Result::by_ptr),
			::pafcore::Result(RuntimeTypeOf<int>::RuntimeType::GetSingleton(), false, ::pafcore::Result::by_value),
			::pafcore::Result(RuntimeTypeOf<int>::RuntimeType::GetSingleton(), false, ::pafcore::Result::by_value),
			::pafcore::Result(RuntimeTypeOf<bool>::RuntimeType::GetSingleton(), false, ::pafcore::Result::by_value),
		};
		static ::pafcore::Argument s_instanceArguments[] = 
		{
			::pafcore::Argument("str", RuntimeTypeOf<char>::RuntimeType::GetSingleton(), ::pafcore::Argument::by_ptr, true),
			::pafcore::Argument("arg", RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), ::pafcore::Argument::by_ref, true),
			::pafcore::Argument("str", RuntimeTypeOf<char>::RuntimeType::GetSingleton(), ::pafcore::Argument::by_ptr, true),
			::pafcore::Argument("arg", RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), ::pafcore::Argument::by_ref, true),
			::pafcore::Argument("str", RuntimeTypeOf<char>::RuntimeType::GetSingleton(), ::pafcore::Argument::by_ptr, true),
			::pafcore::Argument("arg", RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), ::pafcore::Argument::by_ref, true),
		};
		static ::pafcore::Overload s_instanceOverloads[] = 
		{
			::pafcore::Overload(&s_instanceResults[0], &s_instanceArguments[0], 1, false, false),
			::pafcore::Overload(&s_instanceResults[1], &s_instanceArguments[1], 1, false, false),
			::pafcore::Overload(&s_instanceResults[2], &s_instanceArguments[2], 1, false, false),
			::pafcore::Overload(&s_instanceResults[3], &s_instanceArguments[3], 1, false, false),
			::pafcore::Overload(&s_instanceResults[4], 0, 0, false, true),
			::pafcore::Overload(&s_instanceResults[5], &s_instanceArguments[4], 1, false, true),
			::pafcore::Overload(&s_instanceResults[6], &s_instanceArguments[5], 1, false, true),
			::pafcore::Overload(&s_instanceResults[7], 0, 0, false, true),
		};
		static ::pafcore::InstanceMethod s_instanceMethods[] = 
		{
			::pafcore::InstanceMethod("append", 0, String_append, &s_instanceOverloads[0], 2),
			::pafcore::InstanceMethod("assign", 0, String_assign, &s_instanceOverloads[2], 2),
			::pafcore::InstanceMethod("c_str", 0, String_c_str, &s_instanceOverloads[4], 1),
			::pafcore::InstanceMethod("compare", 0, String_compare, &s_instanceOverloads[5], 2),
			::pafcore::InstanceMethod("empty", 0, String_empty, &s_instanceOverloads[7], 1),
		};
		m_instanceMethods = s_instanceMethods;
		m_instanceMethodCount = paf_array_size_of(s_instanceMethods);
		static Metadata* s_members[] = 
		{
			&s_staticMethods[0],
			&s_staticMethods[1],
			&s_instanceMethods[0],
			&s_instanceMethods[1],
			&s_instanceMethods[2],
			&s_instanceMethods[3],
			&s_instanceMethods[4],
		};
		m_members = s_members;
		m_memberCount = paf_array_size_of(s_members);
		::pafcore::NameSpace::GetGlobalNameSpace()->getNameSpace("pafcore")->registerMember(this);
	}

	void __pafcore__String_Type::destroyInstance(void* address)
	{
		delete reinterpret_cast<::pafcore::String*>(address);
	}

	void __pafcore__String_Type::destroyArray(void* address)
	{
		paf_delete_array(reinterpret_cast<::pafcore::String*>(address));
	}

	void __pafcore__String_Type::assign(void* dst, const void* src)
	{
		*(::pafcore::String*)dst = *(const ::pafcore::String*)src;
	}

	::pafcore::ErrorCode __pafcore__String_Type::String_append(::pafcore::Variant* result, ::pafcore::Variant** args, int_t numArgs)
	{
		if(2 <= numArgs)
		{
			size_t candidates[2];
			char argMatches[4];
			size_t matched = ::pafcore::Overload::Resolution(&GetSingleton()->m_instanceMethods[0].m_overloads[0], args, 2, 2, candidates, argMatches);
			switch(matched)
			{
			case 0:
			{
				if(args[0]->isConstant())
				{
					return ::pafcore::e_this_is_constant;
				}
				::pafcore::String* self;
				if(!args[0]->castToValuePtr(GetSingleton(), (void**)&self))
				{
					return ::pafcore::e_invalid_this_type;
				}
				if(args[1]->isTemporary())
				{
					return ::pafcore::e_invalid_arg_type_1;
				}
				const char* a0;
				if(!args[1]->castToPrimitivePtr(RuntimeTypeOf<char>::RuntimeType::GetSingleton(), (void**)&a0))
				{
					return ::pafcore::e_invalid_arg_type_1;
				}
				self->append(a0);
				return ::pafcore::s_ok;
			}
			case 1:
			{
				if(args[0]->isConstant())
				{
					return ::pafcore::e_this_is_constant;
				}
				::pafcore::String* self;
				if(!args[0]->castToValuePtr(GetSingleton(), (void**)&self))
				{
					return ::pafcore::e_invalid_this_type;
				}
				const ::pafcore::String* a0;
				if(!args[1]->castToValuePtr(RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), (void**)&a0))
				{
					return ::pafcore::e_invalid_arg_type_1;
				}
				self->append(*a0);
				return ::pafcore::s_ok;
			}
			case 2:
				return ::pafcore::e_no_match_overload;
			case 3:
				return ::pafcore::e_ambiguous_overload;
			}
		}
		return ::pafcore::e_invalid_arg_num;
	}

	::pafcore::ErrorCode __pafcore__String_Type::String_assign(::pafcore::Variant* result, ::pafcore::Variant** args, int_t numArgs)
	{
		if(2 <= numArgs)
		{
			size_t candidates[2];
			char argMatches[4];
			size_t matched = ::pafcore::Overload::Resolution(&GetSingleton()->m_instanceMethods[1].m_overloads[0], args, 2, 2, candidates, argMatches);
			switch(matched)
			{
			case 0:
			{
				if(args[0]->isConstant())
				{
					return ::pafcore::e_this_is_constant;
				}
				::pafcore::String* self;
				if(!args[0]->castToValuePtr(GetSingleton(), (void**)&self))
				{
					return ::pafcore::e_invalid_this_type;
				}
				if(args[1]->isTemporary())
				{
					return ::pafcore::e_invalid_arg_type_1;
				}
				const char* a0;
				if(!args[1]->castToPrimitivePtr(RuntimeTypeOf<char>::RuntimeType::GetSingleton(), (void**)&a0))
				{
					return ::pafcore::e_invalid_arg_type_1;
				}
				self->assign(a0);
				return ::pafcore::s_ok;
			}
			case 1:
			{
				if(args[0]->isConstant())
				{
					return ::pafcore::e_this_is_constant;
				}
				::pafcore::String* self;
				if(!args[0]->castToValuePtr(GetSingleton(), (void**)&self))
				{
					return ::pafcore::e_invalid_this_type;
				}
				const ::pafcore::String* a0;
				if(!args[1]->castToValuePtr(RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), (void**)&a0))
				{
					return ::pafcore::e_invalid_arg_type_1;
				}
				self->assign(*a0);
				return ::pafcore::s_ok;
			}
			case 2:
				return ::pafcore::e_no_match_overload;
			case 3:
				return ::pafcore::e_ambiguous_overload;
			}
		}
		return ::pafcore::e_invalid_arg_num;
	}

	::pafcore::ErrorCode __pafcore__String_Type::String_c_str(::pafcore::Variant* result, ::pafcore::Variant** args, int_t numArgs)
	{
		if(1 <= numArgs)
		{
			const ::pafcore::String* self;
			if(!args[0]->castToValuePtr(GetSingleton(), (void**)&self))
			{
				return ::pafcore::e_invalid_this_type;
			}
			const char* res = self->c_str();
			result->assignPrimitivePtr(RuntimeTypeOf<char>::RuntimeType::GetSingleton(), res, true, ::pafcore::Variant::by_ptr);
			return ::pafcore::s_ok;
		}
		return ::pafcore::e_invalid_arg_num;
	}

	::pafcore::ErrorCode __pafcore__String_Type::String_compare(::pafcore::Variant* result, ::pafcore::Variant** args, int_t numArgs)
	{
		if(2 <= numArgs)
		{
			size_t candidates[2];
			char argMatches[4];
			size_t matched = ::pafcore::Overload::Resolution(&GetSingleton()->m_instanceMethods[3].m_overloads[0], args, 2, 2, candidates, argMatches);
			switch(matched)
			{
			case 0:
			{
				const ::pafcore::String* self;
				if(!args[0]->castToValuePtr(GetSingleton(), (void**)&self))
				{
					return ::pafcore::e_invalid_this_type;
				}
				if(args[1]->isTemporary())
				{
					return ::pafcore::e_invalid_arg_type_1;
				}
				const char* a0;
				if(!args[1]->castToPrimitivePtr(RuntimeTypeOf<char>::RuntimeType::GetSingleton(), (void**)&a0))
				{
					return ::pafcore::e_invalid_arg_type_1;
				}
				int res = self->compare(a0);
				result->assignPrimitive(RuntimeTypeOf<int>::RuntimeType::GetSingleton(), &res);
				return ::pafcore::s_ok;
			}
			case 1:
			{
				const ::pafcore::String* self;
				if(!args[0]->castToValuePtr(GetSingleton(), (void**)&self))
				{
					return ::pafcore::e_invalid_this_type;
				}
				const ::pafcore::String* a0;
				if(!args[1]->castToValuePtr(RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), (void**)&a0))
				{
					return ::pafcore::e_invalid_arg_type_1;
				}
				int res = self->compare(*a0);
				result->assignPrimitive(RuntimeTypeOf<int>::RuntimeType::GetSingleton(), &res);
				return ::pafcore::s_ok;
			}
			case 2:
				return ::pafcore::e_no_match_overload;
			case 3:
				return ::pafcore::e_ambiguous_overload;
			}
		}
		return ::pafcore::e_invalid_arg_num;
	}

	::pafcore::ErrorCode __pafcore__String_Type::String_empty(::pafcore::Variant* result, ::pafcore::Variant** args, int_t numArgs)
	{
		if(1 <= numArgs)
		{
			const ::pafcore::String* self;
			if(!args[0]->castToValuePtr(GetSingleton(), (void**)&self))
			{
				return ::pafcore::e_invalid_this_type;
			}
			bool res = self->empty();
			result->assignPrimitive(RuntimeTypeOf<bool>::RuntimeType::GetSingleton(), &res);
			return ::pafcore::s_ok;
		}
		return ::pafcore::e_invalid_arg_num;
	}

	::pafcore::ErrorCode __pafcore__String_Type::String_New(::pafcore::Variant* result, ::pafcore::Variant** args, int_t numArgs)
	{
		if(0 == numArgs)
		{
			::pafcore::String* res = ::pafcore::String::New();
			result->assignValuePtr(RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), res, false, ::pafcore::Variant::by_new_ptr);
			return ::pafcore::s_ok;
		}
		if(1 <= numArgs)
		{
			size_t candidates[2];
			char argMatches[2];
			size_t matched = ::pafcore::Overload::Resolution(&GetSingleton()->m_staticMethods[0].m_overloads[1], args, 1, 2, candidates, argMatches);
			switch(matched)
			{
			case 0:
			{
				const ::pafcore::String* a0;
				if(!args[0]->castToValuePtr(RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), (void**)&a0))
				{
					return ::pafcore::e_invalid_arg_type_1;
				}
				::pafcore::String* res = ::pafcore::String::New(*a0);
				result->assignValuePtr(RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), res, false, ::pafcore::Variant::by_new_ptr);
				return ::pafcore::s_ok;
			}
			case 1:
			{
				if(args[0]->isTemporary())
				{
					return ::pafcore::e_invalid_arg_type_1;
				}
				const char* a0;
				if(!args[0]->castToPrimitivePtr(RuntimeTypeOf<char>::RuntimeType::GetSingleton(), (void**)&a0))
				{
					return ::pafcore::e_invalid_arg_type_1;
				}
				::pafcore::String* res = ::pafcore::String::New(a0);
				result->assignValuePtr(RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), res, false, ::pafcore::Variant::by_new_ptr);
				return ::pafcore::s_ok;
			}
			case 2:
				return ::pafcore::e_no_match_overload;
			case 3:
				return ::pafcore::e_ambiguous_overload;
			}
		}
		return ::pafcore::e_invalid_arg_num;
	}

	::pafcore::ErrorCode __pafcore__String_Type::String_NewArray(::pafcore::Variant* result, ::pafcore::Variant** args, int_t numArgs)
	{
		if(1 <= numArgs)
		{
			unsigned int a0;
			if(!args[0]->castToPrimitive(RuntimeTypeOf<unsigned int>::RuntimeType::GetSingleton(), &a0))
			{
				return ::pafcore::e_invalid_arg_type_1;
			}
			::pafcore::String* res = ::pafcore::String::NewArray(a0);
			result->assignArray(RuntimeTypeOf<::pafcore::String>::RuntimeType::GetSingleton(), res, paf_new_array_size_of(res), false, ::pafcore::Variant::by_new_array);
			return ::pafcore::s_ok;
		}
		return ::pafcore::e_invalid_arg_num;
	}

	__pafcore__String_Type* __pafcore__String_Type::GetSingleton()
	{
		static __pafcore__String_Type* s_instance = 0;
		static char s_buffer[sizeof(__pafcore__String_Type)];
		if(0 == s_instance)
		{
			s_instance = (__pafcore__String_Type*)s_buffer;
			new (s_buffer)__pafcore__String_Type;
		}
		return s_instance;
	}

}

AUTO_REGISTER_TYPE(::idlcpp::__pafcore__String_Type)
